/**
 * @Date:   2018-08-06
 * @Email:  ni-ys13@qq.com
 * @Last modified time: 2018-08-06
 */
/*题目描述
kls要打一个血量为 nnn 的史莱姆，每回合他可以攻击一次，造成 kkk 点伤害。当一个史莱姆的血量小于等于0时，就会死亡。
如果一个史莱姆受到攻击后，当前血量小于等于最大血量的一半，且没有死亡，就会分裂成两个史莱姆，它们的当前血量和最大血量都等于分裂前的血量。
假设史莱姆不会攻击，只会挨打，求kls打掉所有史莱姆需要的回合数。
输入格式：
一行两个正整数 n,kn,kn,k ，含义如上。
输出格式：
一个数，表示需要的回合数。

输入样例60 10
输出样例11
样例的解释
一开始，有1个血量为60的史莱姆。
kls攻击3次之后，它的血量变为30，分裂成2个30血的史莱姆。
对其中一个攻击2次之后，它的血量变为10，分裂成2个10血的史莱姆。再对每个10血的史莱姆攻击1次，它的血量变为0，直接死亡。
对另一个也是同样的操作。
总共需要 3+2+1+1+2+1+1=113+2+1+1+2+1+1=113+2+1+1+2+1+1=11 个回合。
*/
/*
kls与爬塔
30分做法
模拟递归计算即可，复杂度 O(nlog⁡n)。
60分做法
注意到每次分裂出来的两个史莱姆是完全一样的，不用分别递归，只要乘以2就行了，复杂度 O(n)。
100分做法
在60分做法的基础上，使用long long，并在计算攻击次数时使用除法，就可以通过本题，复杂度 O(log⁡n)。
*/
#include <cstdio>

typedef long long ll;
ll n, k;

ll solve(ll n) {
    ll x = n;
    ll ans = 0;
    ll t = (n - n / 2 - 1) / k + 1;
    ans += t;
    x -= t * k;
    if (x > 0) ans += solve(x) * 2;
    return ans;
}

int main() {
    scanf("%lld%lld", &n, &k);
    printf("%lld\n", solve(n));
}
